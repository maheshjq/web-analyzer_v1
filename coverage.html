
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maheshjq/web-analyzer_v1/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/maheshjq/web-analyzer_v1/docs/docs.go (100.0%)</option>
				
				<option value="file2">github.com/maheshjq/web-analyzer_v1/internal/analyzer/analyzer.go (94.5%)</option>
				
				<option value="file3">github.com/maheshjq/web-analyzer_v1/internal/api/analyzer_interface.go (87.5%)</option>
				
				<option value="file4">github.com/maheshjq/web-analyzer_v1/internal/api/analyzer_mock.go (100.0%)</option>
				
				<option value="file5">github.com/maheshjq/web-analyzer_v1/internal/api/cached_analyzer.go (57.8%)</option>
				
				<option value="file6">github.com/maheshjq/web-analyzer_v1/internal/api/handlers.go (88.9%)</option>
				
				<option value="file7">github.com/maheshjq/web-analyzer_v1/internal/api/middleware.go (100.0%)</option>
				
				<option value="file8">github.com/maheshjq/web-analyzer_v1/internal/api/swagger.go (0.0%)</option>
				
				<option value="file9">github.com/maheshjq/web-analyzer_v1/internal/api/types.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gorilla/mux"
        "github.com/rs/cors"
        httpSwagger "github.com/swaggo/http-swagger"

        "github.com/maheshjq/web-analyzer_v1/internal/api"
        // Uncomment when you have generated swagger docs
        _ "github.com/maheshjq/web-analyzer_v1/docs"
)

func init() {<span class="cov8" title="1">
        // api.NewAnalyzerFunc = func() api.Analyzer {
        //         // Create default analyzer
        //         defaultAnalyzer := &amp;api.DefaultAnalyzer{}

        //         // Wrap with caching (cache results for 5 minutes)
        //         return api.NewCachedAnalyzer(defaultAnalyzer, 5*time.Minute)
        // }
}</span>

// @title Web Page Analyzer API
// @version 1.0
// @description API for analyzing web pages, extracting HTML version, title, headings, links, and detecting login forms.

// @contact.name Web Analyzer Team

// @host localhost:8080
// @BasePath /
// @schemes http

func main() <span class="cov0" title="0">{
        api.EnableCaching = true
        // Setup logger for the app
        logger := slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))

        // Create the router for handling routes
        router := mux.NewRouter()

        // Define all API endpoints here
        apiRouter := router.PathPrefix("/api").Subrouter()
        apiRouter.HandleFunc("/analyze", api.AnalyzeHandler).Methods("POST", "OPTIONS")
        apiRouter.HandleFunc("/health", api.HealthCheckHandler).Methods("GET")

        // Setup Swagger UI for API docs
        router.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
                httpSwagger.URL("/swagger/doc.json"),
                httpSwagger.DeepLinking(true),
                httpSwagger.DocExpansion("none"),
        ))

        // Serve static files from the web build directory
        spa := http.FileServer(http.Dir("./web/build"))
        router.PathPrefix("/").Handler(spa)

        // Add middleware for logging and recovery
        router.Use(api.LoggingMiddleware(logger))
        router.Use(api.RecoverMiddleware(logger))

        // Setup CORS so the frontend can talk to the backend
        corsHandler := cors.New(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowedMethods:   []string{"GET", "POST", "OPTIONS"},
                AllowedHeaders:   []string{"Content-Type", "Authorization"},
                AllowCredentials: true,
        }).Handler(router)

        // Get the port from env or use 8080 as default
        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        // Configure the HTTP server
        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:         ":" + port,
                Handler:      corsHandler,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 30 * time.Second,
                IdleTimeout:  120 * time.Second,
        }

        // Start the server in a goroutine
        go func() </span><span class="cov0" title="0">{
                fmt.Printf("Server starting on :%s\n", port)
                fmt.Println("Swagger UI available at http://localhost:" + port + "/swagger/")
                // logger.Info("Server started", "port", port) // Left this commented out from debugging
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Server crashed: %v", err)
                }</span>
        }()

        // Wait for an interrupt signal to shut down
        <span class="cov0" title="0">c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt, syscall.SIGTERM)
        &lt;-c

        // Gracefully shutdown the server
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("Shutdown failed", "error", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("Server gracefully stopped")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Web Analyzer Team"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/analyze": {
            "post": {
                "description": "Fetches and analyzes a web page by URL, returning information about its structure and content",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "analysis"
                ],
                "summary": "Analyze a web page",
                "parameters": [
                    {
                        "description": "URL to analyze",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.AnalysisRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful analysis",
                        "schema": {
                            "$ref": "#/definitions/models.AnalysisResponse"
                        }
                    },
                    "400": {
                        "description": "Bad request (invalid URL format)",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Failed to fetch or analyze the URL",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/health": {
            "get": {
                "description": "Returns the health status of the API",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Health check",
                "responses": {
                    "200": {
                        "description": "Service is healthy",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.AnalysisRequest": {
            "type": "object",
            "properties": {
                "url": {
                    "type": "string",
                    "example": "https://example.com"
                }
            }
        },
        "models.AnalysisResponse": {
            "type": "object",
            "properties": {
                "containsLoginForm": {
                    "type": "boolean",
                    "example": false
                },
                "headings": {
                    "$ref": "#/definitions/models.HeadingCount"
                },
                "htmlVersion": {
                    "type": "string",
                    "example": "HTML5"
                },
                "links": {
                    "$ref": "#/definitions/models.LinkAnalysis"
                },
                "title": {
                    "type": "string",
                    "example": "Example Domain"
                }
            }
        },
        "models.ErrorResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string",
                    "example": "Failed to analyze URL: HTTP error 404 Not Found"
                },
                "statusCode": {
                    "type": "integer",
                    "example": 502
                }
            }
        },
        "models.HeadingCount": {
            "type": "object",
            "properties": {
                "h1": {
                    "type": "integer",
                    "example": 1
                },
                "h2": {
                    "type": "integer",
                    "example": 2
                },
                "h3": {
                    "type": "integer",
                    "example": 3
                },
                "h4": {
                    "type": "integer",
                    "example": 0
                },
                "h5": {
                    "type": "integer",
                    "example": 0
                },
                "h6": {
                    "type": "integer",
                    "example": 0
                }
            }
        },
        "models.LinkAnalysis": {
            "type": "object",
            "properties": {
                "external": {
                    "type": "integer",
                    "example": 3
                },
                "inaccessible": {
                    "type": "integer",
                    "example": 1
                },
                "internal": {
                    "type": "integer",
                    "example": 5
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{"http"},
        Title:            "Web Page Analyzer API",
        Description:      "API for analyzing web pages, extracting HTML version, title, headings, links, and detecting login forms.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package analyzer

import (
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "sync"
        "time"

        "golang.org/x/net/html"

        "github.com/maheshjq/web-analyzer_v1/internal/models"
)

type Analyzer struct {
        client *http.Client
}

func NewAnalyzer() *Analyzer <span class="cov8" title="1">{
        return &amp;Analyzer{
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
        }
}</span>

// Analyze performs a full analysis of the webpage at the given URL
func (a *Analyzer) Analyze(targetURL string) (*models.AnalysisResponse, error) <span class="cov8" title="1">{
        // Fetch the page
        resp, err := a.client.Get(targetURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch URL: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Check for successful response
        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("HTTP error: %d %s", resp.StatusCode, resp.Status)
        }</span>

        // Parse the HTML
        <span class="cov8" title="1">doc, err := html.Parse(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse HTML: %w", err)
        }</span>

        // Parse the base URL for link analysis
        <span class="cov8" title="1">baseURL, err := url.Parse(targetURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse base URL: %w", err)
        }</span>

        // Analyze the document
        <span class="cov8" title="1">result := &amp;models.AnalysisResponse{
                Headings: models.HeadingCount{},
                Links:    models.LinkAnalysis{},
        }

        result.HTMLVersion = detectHTMLVersion(doc)

        result.Title = extractTitle(doc)

        countHeadings(doc, &amp;result.Headings)

        result.Links = analyzeLinks(doc, baseURL.Host, a.client)

        result.ContainsLoginForm = detectLoginForm(doc)

        return result, nil</span>
}

func detectHTMLVersion(doc *html.Node) string <span class="cov8" title="1">{
        if doc.Type == html.DocumentNode </span><span class="cov8" title="1">{
                for child := doc.FirstChild; child != nil; child = child.NextSibling </span><span class="cov8" title="1">{
                        if child.Type == html.DoctypeNode </span><span class="cov8" title="1">{
                                // HTML5: &lt;!DOCTYPE html&gt; with no attributes
                                if strings.ToLower(child.Data) == "html" &amp;&amp; len(child.Attr) == 0 </span><span class="cov8" title="1">{
                                        return "HTML5"
                                }</span>
                                // Check for older versions
                                <span class="cov8" title="1">for _, attr := range child.Attr </span><span class="cov8" title="1">{
                                        if attr.Key == "public" </span><span class="cov8" title="1">{
                                                pubID := strings.ToLower(attr.Val)
                                                if strings.Contains(pubID, "html 4") </span><span class="cov8" title="1">{
                                                        return "HTML 4.01"
                                                }</span> else<span class="cov8" title="1"> if strings.Contains(pubID, "xhtml 1.0") </span><span class="cov8" title="1">{
                                                        return "XHTML 1.0"
                                                }</span> else<span class="cov8" title="1"> if strings.Contains(pubID, "xhtml 1.1") </span><span class="cov8" title="1">{
                                                        return "XHTML 1.1"
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">return "Unknown DOCTYPE"</span>
                        }
                }
        }
        // Check for HTML5 elements if no doctype
        <span class="cov8" title="1">html5Elements := []string{"article", "aside", "audio", "canvas", "footer", "header", "nav", "section", "video"}
        for _, element := range html5Elements </span><span class="cov8" title="1">{
                if findElement(doc, element) </span><span class="cov8" title="1">{
                        return "HTML5 (No DOCTYPE)"
                }</span>
        }
        <span class="cov8" title="1">return "Unknown (No DOCTYPE)"</span>
}

// findElement searches for a specific element in the document
func findElement(n *html.Node, tagName string) bool <span class="cov8" title="1">{
        if n.Type == html.ElementNode &amp;&amp; strings.ToLower(n.Data) == tagName </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                if findElement(c, tagName) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func extractTitle(doc *html.Node) string <span class="cov8" title="1">{
        var title string
        var findTitle func(*html.Node) bool
        findTitle = func(n *html.Node) bool </span><span class="cov8" title="1">{
                if n.Type == html.ElementNode &amp;&amp; n.Data == "title" </span><span class="cov8" title="1">{
                        // Get text content with HTML tags stripped
                        var b strings.Builder
                        for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                                if c.Type == html.TextNode </span><span class="cov8" title="1">{
                                        b.WriteString(c.Data)
                                }</span> else<span class="cov0" title="0"> if c.Type == html.ElementNode </span><span class="cov0" title="0">{
                                        // Recursively get text from child elements
                                        var childText string
                                        for child := c.FirstChild; child != nil; child = child.NextSibling </span><span class="cov0" title="0">{
                                                if child.Type == html.TextNode </span><span class="cov0" title="0">{
                                                        childText += child.Data
                                                }</span>
                                        }
                                        <span class="cov0" title="0">b.WriteString(childText)</span>
                                }
                        }
                        <span class="cov8" title="1">title = b.String()
                        return true</span> // Stop searching after finding first title
                }

                <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                        if findTitle(c) </span><span class="cov8" title="1">{
                                return true // Propagate the "found" signal up
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">findTitle(doc)
        return title</span>
}

func countHeadings(doc *html.Node, headings *models.HeadingCount) <span class="cov8" title="1">{
        var crawler func(*html.Node)

        crawler = func(n *html.Node) </span><span class="cov8" title="1">{
                if n.Type == html.ElementNode </span><span class="cov8" title="1">{
                        switch n.Data </span>{
                        case "h1":<span class="cov8" title="1">
                                headings.H1++</span>
                        case "h2":<span class="cov8" title="1">
                                headings.H2++</span>
                        case "h3":<span class="cov8" title="1">
                                headings.H3++</span>
                        case "h4":<span class="cov8" title="1">
                                headings.H4++</span>
                        case "h5":<span class="cov8" title="1">
                                headings.H5++</span>
                        case "h6":<span class="cov8" title="1">
                                headings.H6++</span>
                        }
                }

                <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                        crawler(c)
                }</span>
        }

        <span class="cov8" title="1">crawler(doc)</span>
}

func analyzeLinks(doc *html.Node, host string, client *http.Client) models.LinkAnalysis <span class="cov8" title="1">{
        var links []string
        var extractLinks func(*html.Node)
        extractLinks = func(n *html.Node) </span><span class="cov8" title="1">{
                if n.Type == html.ElementNode &amp;&amp; n.Data == "a" </span><span class="cov8" title="1">{
                        for _, attr := range n.Attr </span><span class="cov8" title="1">{
                                if attr.Key == "href" </span><span class="cov8" title="1">{
                                        links = append(links, attr.Val)
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                        extractLinks(c)
                }</span>
        }
        <span class="cov8" title="1">extractLinks(doc)

        // Define a result struct for channel communication
        type linkResult struct {
                isInternal     bool
                isExternal     bool
                isInaccessible bool
        }

        resultCh := make(chan linkResult, len(links))
        var wg sync.WaitGroup

        for _, link := range links </span><span class="cov8" title="1">{
                if link == "" || strings.HasPrefix(link, "javascript:") </span><span class="cov8" title="1">{
                        continue</span> // Skip empty or js links
                }

                <span class="cov8" title="1">wg.Add(1)
                go func(l string) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        result := linkResult{
                                isInternal:     isInternalLink(l, host),
                                isExternal:     !isInternalLink(l, host),
                                isInaccessible: false,
                        }

                        if strings.HasPrefix(l, "http") </span><span class="cov8" title="1">{
                                fmt.Println("Checking accessibility for:", l) // Debug print
                                if !isAccessibleLink(l, client) </span><span class="cov8" title="1">{
                                        fmt.Println("Inaccessible link found:", l) // Debug print
                                        result.isInaccessible = true
                                }</span>
                        }

                        <span class="cov8" title="1">resultCh &lt;- result</span>
                }(link)
        }

        // Close the channel when all goroutines complete
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultCh)
        }</span>()

        // Count the results
        <span class="cov8" title="1">var internal, external, inaccessible int
        for result := range resultCh </span><span class="cov8" title="1">{
                if result.isInternal </span><span class="cov8" title="1">{
                        internal++
                }</span>
                <span class="cov8" title="1">if result.isExternal </span><span class="cov8" title="1">{
                        external++
                }</span>
                <span class="cov8" title="1">if result.isInaccessible </span><span class="cov8" title="1">{
                        inaccessible++
                }</span>
        }

        <span class="cov8" title="1">return models.LinkAnalysis{
                Internal:     internal,
                External:     external,
                Inaccessible: inaccessible,
        }</span>
}

func isInternalLink(href, host string) bool <span class="cov8" title="1">{
        if href == "" || strings.HasPrefix(href, "#") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(href, "/") || strings.HasPrefix(href, "./") || strings.HasPrefix(href, "../") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">u, err := url.Parse(href)
        if err != nil || (u.Scheme != "" &amp;&amp; u.Scheme != "http" &amp;&amp; u.Scheme != "https") </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return u.Host == host || u.Host == ""</span>
}

func isAccessibleLink(link string, client *http.Client) bool <span class="cov8" title="1">{
        // Fragment links are considered accessible
        if strings.HasPrefix(link, "#") </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">resp, err := client.Head(link)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // 2xx and 3xx status codes are considered accessible
        return resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 400</span>
}

// detectLoginForm detects if the document contains a login form
func detectLoginForm(doc *html.Node) bool <span class="cov8" title="1">{
        var hasLoginForm bool

        var crawler func(*html.Node)
        crawler = func(n *html.Node) </span><span class="cov8" title="1">{
                if hasLoginForm </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">if n.Type == html.ElementNode &amp;&amp; n.Data == "form" </span><span class="cov8" title="1">{
                        // Check for form attributes that suggest a login form
                        var formAction, formId, formClass string
                        for _, attr := range n.Attr </span><span class="cov8" title="1">{
                                switch attr.Key </span>{
                                case "action":<span class="cov8" title="1">
                                        formAction = strings.ToLower(attr.Val)</span>
                                case "id":<span class="cov8" title="1">
                                        formId = strings.ToLower(attr.Val)</span>
                                case "class":<span class="cov8" title="1">
                                        formClass = strings.ToLower(attr.Val)</span>
                                }
                        }

                        <span class="cov8" title="1">if strings.Contains(formAction, "login") ||
                                strings.Contains(formAction, "signin") ||
                                strings.Contains(formId, "login") ||
                                strings.Contains(formId, "signin") ||
                                strings.Contains(formClass, "login") ||
                                strings.Contains(formClass, "signin") </span><span class="cov8" title="1">{
                                hasLoginForm = true
                                return
                        }</span>

                        // Check form elements for password inputs
                        <span class="cov8" title="1">var formCrawler func(*html.Node)
                        formCrawler = func(node *html.Node) </span><span class="cov8" title="1">{
                                if node.Type == html.ElementNode &amp;&amp; node.Data == "input" </span><span class="cov8" title="1">{
                                        for _, attr := range node.Attr </span><span class="cov8" title="1">{
                                                if attr.Key == "type" &amp;&amp; attr.Val == "password" </span><span class="cov8" title="1">{
                                                        hasLoginForm = true
                                                        return
                                                }</span>
                                        }
                                }

                                <span class="cov8" title="1">for c := node.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                                        formCrawler(c)
                                }</span>
                        }

                        <span class="cov8" title="1">formCrawler(n)</span>
                }

                <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                        crawler(c)
                }</span>
        }

        <span class="cov8" title="1">crawler(doc)
        return hasLoginForm</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "sync"
        "time"

        "github.com/maheshjq/web-analyzer_v1/internal/analyzer"
        "github.com/maheshjq/web-analyzer_v1/internal/models"
)

// toggle flag -&gt; enable/disable caching
var EnableCaching = true

// Analyzer interface defines the behavior for a web page analyzer
type Analyzer interface {
        Analyze(url string) (*models.AnalysisResponse, error)
}

// Global singleton
var singletonAnalyzer Analyzer
var once sync.Once

func GetAnalyzer() Analyzer <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                realAnalyzer := &amp;DefaultAnalyzer{}

                if EnableCaching </span><span class="cov8" title="1">{
                        // Cache results if caching is enabled
                        singletonAnalyzer = NewCachedAnalyzer(realAnalyzer, 15*time.Minute)
                }</span> else<span class="cov0" title="0"> {
                        // Use analyzer directly if caching is disabled
                        singletonAnalyzer = realAnalyzer
                }</span>
        })
        <span class="cov8" title="1">return singletonAnalyzer</span>
}

// DefaultAnalyzer is a wrapper for the actual analyzer imple
type DefaultAnalyzer struct{}

// Analyze implements the Analyzer interface by calling the actual analyzer
func (da *DefaultAnalyzer) Analyze(url string) (*models.AnalysisResponse, error) <span class="cov8" title="1">{
        // Create an instance of actual analyzer
        realAnalyzer := analyzer.NewAnalyzer()

        // Call the actual analyze method
        return realAnalyzer.Analyze(url)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
    "github.com/maheshjq/web-analyzer_v1/internal/models"
)

// MockAnalyzer is a test implementation of the Analyzer interface
type MockAnalyzer struct {
    AnalyzeFn func(url string) (*models.AnalysisResponse, error)
}

// Analyze calls the mock implementation function
func (m *MockAnalyzer) Analyze(url string) (*models.AnalysisResponse, error) <span class="cov8" title="1">{
    return m.AnalyzeFn(url)
}</pre>
		
		<pre class="file" id="file5" style="display: none">// internal/api/cached_analyzer.go
package api

import (
        "log"
        "sync"
        "time"

        "github.com/maheshjq/web-analyzer_v1/internal/models"
)

// CachedResult holds a cached analysis result and its expiration time
type CachedResult struct {
        Result    *models.AnalysisResponse
        ExpiresAt time.Time
}

// NewCachedAnalyzer creates a new cached analyzer
func NewCachedAnalyzer(delegate Analyzer, ttl time.Duration) *CachedAnalyzer <span class="cov8" title="1">{
        ca := &amp;CachedAnalyzer{
                delegate: delegate,
                cache:    make(map[string]CachedResult),
                ttl:      ttl,
        }

        // Start a goroutine to periodically clean the cache
        go ca.cleanupCache(ttl)

        return ca
}</span>

// Add this method
func (ca *CachedAnalyzer) cleanupCache(interval time.Duration) <span class="cov8" title="1">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                now := time.Now()
                ca.mu.Lock()
                for url, cached := range ca.cache </span><span class="cov0" title="0">{
                        if now.After(cached.ExpiresAt) </span><span class="cov0" title="0">{
                                delete(ca.cache, url)
                        }</span>
                }
                <span class="cov0" title="0">ca.mu.Unlock()</span>
        }
}

// Analyze implements the Analyzer interface with caching
func (ca *CachedAnalyzer) Analyze(url string) (*models.AnalysisResponse, error) <span class="cov8" title="1">{
        start := time.Now()

        // Check cache first
        ca.mu.RLock()
        cached, found := ca.cache[url]
        ca.mu.RUnlock()

        now := time.Now()

        // If found and not expired, return the cached result
        if found &amp;&amp; now.Before(cached.ExpiresAt) </span><span class="cov0" title="0">{
                ca.mu.Lock()
                ca.cacheHits++
                ca.mu.Unlock()
                log.Printf("CACHE HIT for %s - returning cached result (%.2f ms)",
                        url, float64(time.Since(start).Microseconds())/1000)
                return cached.Result, nil
        }</span>

        <span class="cov8" title="1">ca.mu.Lock()
        ca.cacheMisses++
        ca.mu.Unlock()
        log.Printf("CACHE MISS for %s - performing analysis", url)

        // Not in cache or expired, call the delegate
        analysisStart := time.Now()
        result, err := ca.delegate.Analyze(url)
        analysisDuration := time.Since(analysisStart)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR analyzing %s: %v", url, err)
                return nil, err
        }</span>

        <span class="cov8" title="1">log.Printf("Analysis completed for %s (took %.2f sec)",
                url, analysisDuration.Seconds())

        // Store in cache
        ca.mu.Lock()
        ca.cache[url] = CachedResult{
                Result:    result,
                ExpiresAt: now.Add(ca.ttl),
        }
        ca.mu.Unlock()
        log.Printf("Cached result for %s (expires in %v)", url, ca.ttl)

        return result, nil</span>
}

type CachedAnalyzer struct {
        delegate    Analyzer
        cache       map[string]CachedResult
        ttl         time.Duration
        mu          sync.RWMutex
        cacheHits   int
        cacheMisses int
}

// Add methods to get metrics
func (ca *CachedAnalyzer) CacheHits() int <span class="cov0" title="0">{
        ca.mu.RLock()
        defer ca.mu.RUnlock()
        return ca.cacheHits
}</span>

func (ca *CachedAnalyzer) CacheMisses() int <span class="cov0" title="0">{
        ca.mu.RLock()
        defer ca.mu.RUnlock()
        return ca.cacheMisses
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "net/url"
        "strings"

        // "github.com/maheshjq/web-analyzer_v1/internal/analyzer_interface"
        "github.com/maheshjq/web-analyzer_v1/internal/models"
)

// AnalyzeHandler handles POST requests to the /api/analyze endpoint.
// It takes a JSON body with a URL and digs into the web page to pull out useful details about its structure and content.
//
// @Summary Analyze a web page
// @Description
// This endpoint analyzes a web page based on the URL you provide and returns a breakdown of its key features, including:
// - HTML version (like HTML5 or XHTML 1.0)
// - Page title
// - Counts of headings (h1 through h6)
// - Link analysis:
//   - Number of internal links
//   - Number of external links
//   - Number of inaccessible links
//
// - Whether there's a login form on the page
// @Tags analysis
// @Accept json
// @Produce json
// @Param request body models.AnalysisRequest true "URL to analyze"
// @Success 200 {object} models.AnalysisResponse "Successful analysis"
// @Failure 400 {object} models.ErrorResponse "Invalid URL format or missing URL"
// @Failure 502 {object} models.ErrorResponse "Unable to fetch the URL or an error occurred during analysis"
// @Router /api/analyze [post]
func AnalyzeHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")

        var req models.AnalysisRequest
        err := json.NewDecoder(r.Body).Decode(&amp;req)
        if err != nil </span><span class="cov8" title="1">{
                sendErrorResponse(w, http.StatusBadRequest, "Invalid request body: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">if req.URL == "" </span><span class="cov8" title="1">{
                sendErrorResponse(w, http.StatusBadRequest, "URL is required")
                return
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(req.URL, "http://") &amp;&amp; !strings.HasPrefix(req.URL, "https://") </span><span class="cov0" title="0">{
                req.URL = "https://" + req.URL
        }</span>

        <span class="cov8" title="1">_, err = url.ParseRequestURI(req.URL)
        if err != nil </span><span class="cov0" title="0">{
                sendErrorResponse(w, http.StatusBadRequest, "Invalid URL format: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">analyzerInstance := GetAnalyzer()

        // Analyze the url here
        analysisResult, err := analyzerInstance.Analyze(req.URL)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error analyzing URL %s: %v", req.URL, err)
                sendErrorResponse(w, http.StatusBadGateway, fmt.Sprintf("Failed to analyze URL: %v", err))
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(analysisResult)</span>
}

// HealthCheckHandler godoc
// @Summary Health check
// @Description Returns the health status of the API
// @Tags health
// @Produce json
// @Success 200 {object} map[string]string "Service is healthy"
// @Router /api/health [get]
func HealthCheckHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        fmt.Fprintf(w, `{"status": "ok"}`)
}</span>

func sendErrorResponse(w http.ResponseWriter, statusCode int, message string) <span class="cov8" title="1">{
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(models.ErrorResponse{
                StatusCode: statusCode,
                Message:    message,
        })
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "log/slog"
        "net/http"
        "time"
)

func LoggingMiddleware(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        start := time.Now()

                        logger.Info("Request started",
                                "method", r.Method,
                                "path", r.URL.Path,
                                "remote_addr", r.RemoteAddr,
                                "user_agent", r.UserAgent(),
                        )

                        next.ServeHTTP(w, r)

                        logger.Info("Request completed",
                                "method", r.Method,
                                "path", r.URL.Path,
                                "duration", time.Since(start).String(),
                        )
                }</span>)
        }
}

func CorsMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

func RecoverMiddleware(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if err := recover(); err != nil </span><span class="cov8" title="1">{
                                        logger.Error("Panic recovered",
                                                "error", err,
                                                "path", r.URL.Path,
                                                "method", r.Method,
                                        )

                                        w.Header().Set("Content-Type", "application/json")
                                        w.WriteHeader(http.StatusInternalServerError)
                                        w.Write([]byte(`{"statusCode": 500, "message": "Internal Server Error"}`))
                                }</span>
                        }()

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "github.com/gorilla/mux"
        httpSwagger "github.com/swaggo/http-swagger"
)

func SetupSwagger(router *mux.Router) <span class="cov0" title="0">{
        router.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
                httpSwagger.URL("/swagger/doc.json"),
                httpSwagger.DeepLinking(true),
                httpSwagger.DocExpansion("none"),
                httpSwagger.DomID("swagger-ui"),
        ))
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "log/slog"
        "net/http"
)

type Handler struct {
        logger *slog.Logger
}

func NewHandler(logger *slog.Logger) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                logger: logger,
        }
}</span>

func (h *Handler) sendError(w http.ResponseWriter, statusCode int, message string) <span class="cov0" title="0">{
        w.WriteHeader(statusCode)
        w.Write([]byte(`{"statusCode": ` + string(rune(statusCode)) + `, "message": "` + message + `"}`))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
